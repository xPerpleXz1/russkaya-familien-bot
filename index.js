const { 
    Client, 
    GatewayIntentBits, 
    SlashCommandBuilder, 
    EmbedBuilder, 
    AttachmentBuilder,
    ActivityType,
    PermissionFlagsBits 
} = require('discord.js');

const express = require('express');
const cron = require('node-cron');
require('dotenv').config();

// ===== PFLANZEN-KONFIGURATION =====
const PLANT_TYPES = {
    mandarinen: {
        name: 'Mandarinen üçä',
        emoji: 'üçä',
        growthTime: 180,        // 3 Stunden
        baseReward: 800,
        seedCost: 150,
        fertilizeTime1: 30,
        fertilizeTime2: 90,
        description: 'Schnell wachsend, mittlerer Ertrag'
    },
    ananas: {
        name: 'Ananas üçç',
        emoji: 'üçç',
        growthTime: 300,        // 5 Stunden
        baseReward: 1500,
        seedCost: 250,
        fertilizeTime1: 45,
        fertilizeTime2: 150,
        description: 'Langsam wachsend, hoher Ertrag'
    },
    kohl: {
        name: 'Kohl ü•¨',
        emoji: 'ü•¨',
        growthTime: 120,        // 2 Stunden
        baseReward: 500,
        seedCost: 100,
        fertilizeTime1: 20,
        fertilizeTime2: 60,
        description: 'Sehr schnell wachsend, niedriger Ertrag'
    }
};

// ===== NEUE AKTIVIT√ÑTEN KONFIGURATION =====
const ACTIVITY_TYPES = {
    // Raids & Events
    raid: {
        name: 'Raid',
        emoji: 'üî´',
        reward: 10000,
        description: 'Pro Person bei erfolgreichem Raid'
    },
    hafen_event: {
        name: 'Hafen Event',
        emoji: 'üö¢',
        reward: 50000,
        description: 'Bei Abgabe von wertvollen Containern'
    },
    mount_chiliad: {
        name: 'Mount Chiliad',
        emoji: '‚õ∞Ô∏è',
        reward: 30000,
        description: 'Bei Abgabe von We.Co.+W√ºstenschalcontainer'
    },
    ekz: {
        name: 'EKZ (Einkaufszentrum)',
        emoji: 'üè¨',
        reward: 100000,
        description: 'Pro Person bei Gewinn'
    },
    shop_raub: {
        name: 'Shop Raub',
        emoji: 'üè™',
        reward: 10000,
        description: 'Ca. 10k pro Person (je nach Geschehen)'
    },
    flugzeugtraeger: {
        name: 'Flugzeugtr√§ger Drop',
        emoji: '‚úàÔ∏è',
        reward: 20000,
        description: 'F√ºr Drop-Aktivit√§t'
    },
    
    // Passive Einnahmen
    gelddruckmaschine: {
        name: 'Gelddruckmaschine',
        emoji: 'üí∏',
        reward: 2000,
        description: 'Alle 5 Minuten automatisch',
        interval: 5
    },
    
    // Andere Aktivit√§ten
    solar_abgabe: {
        name: 'Solar Batterie Abgabe',
        emoji: 'üîã',
        reward: 10000,
        description: 'Pro Person bei Batterie-Abgabe'
    },
    pilzfarm: {
        name: 'Pilzfarm',
        emoji: 'üçÑ',
        reward: 800,
        description: 'Pro Person bei Pilz-Abgabe'
    },
    
    // Ausbildung
    recruitment: {
        name: 'Rekrutierung',
        emoji: 'üë•',
        reward: 20000,
        description: 'Pro eingeladene Person (1+ Woche aktiv)'
    }
};

// ===== ERWEITERTE AUSZAHLUNGS-RATEN =====
const PAYOUT_RATES = {
    // Pflanzen-Aktivit√§ten
    PLANTED: {
        mandarinen: 400,
        ananas: 600,
        kohl: 300
    },
    FERTILIZED_OWN: 200,
    FERTILIZED_TEAM: 400,
    BEETE_DUENGEN: 1000,        // NEU: Externe Beete d√ºngen
    HARVESTED_OWN: {
        mandarinen: 600,
        ananas: 1000,
        kohl: 400
    },
    HARVESTED_TEAM: {
        mandarinen: 450,
        ananas: 800,
        kohl: 300
    },
    
    // Solar-Aktivit√§ten
    PLACED: 700,
    REPAIRED_OWN: 300,
    REPAIRED_TEAM: 500,
    SOLAR_REPARIEREN: 1000,     // NEU: Externe Solar reparieren
    COLLECTED_OWN: 1000,
    COLLECTED_TEAM: 800,
    
    // Neue Aktivit√§ten
    ...Object.fromEntries(
        Object.entries(ACTIVITY_TYPES).map(([key, activity]) => [
            key.toUpperCase(), activity.reward
        ])
    ),
    
    // Bonus-Multiplkatoren
    QUALITY_BONUS: 1.2,
    SPEED_BONUS: 1.5,
    LEVEL_BONUS: 0.05
};

// ===== KONFIGURATION =====
const config = {
    token: process.env.DISCORD_TOKEN,
    port: process.env.PORT || 3000,
    
    database: {
        connectionString: process.env.DATABASE_URL,
        ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
    },
    
    channels: {
        plant: process.env.PLANT_CHANNEL_ID,
        solar: process.env.SOLAR_CHANNEL_ID,
        backup: process.env.BACKUP_CHANNEL_ID,
        logs: process.env.LOGS_CHANNEL_ID,
        activities: process.env.ACTIVITIES_CHANNEL_ID || process.env.LOGS_CHANNEL_ID
    },
    
    timers: {
        solarRepairReminder1: 30,
        solarRepairReminder2: 50,
        solarBatteryTime: 120,
        cleanupInterval: 7 * 24 * 60,
        backupInterval: 24 * 60,
        gelddruckInterval: 5
    }
};

// ===== BOT SETUP =====
const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.GuildMessageReactions,
        GatewayIntentBits.GuildMembers
    ]
});

// ===== DATENBANK SETUP =====
let db;

function initializeDatabase() {
    if (config.database.connectionString) {
        const { Pool } = require('pg');
        db = new Pool({
            connectionString: config.database.connectionString,
            ssl: config.database.ssl
        });
        console.log('üêò PostgreSQL Verbindung initialisiert');
    } else {
        try {
            const sqlite3 = require('sqlite3').verbose();
            db = {
                query: (text, params) => {
                    return new Promise((resolve, reject) => {
                        const sqliteDb = new sqlite3.Database('./russkaya.db');
                        sqliteDb.all(text.replace(/\$(\d+)/g, '?'), params || [], (err, rows) => {
                            if (err) reject(err);
                            else resolve({ rows });
                            sqliteDb.close();
                        });
                    });
                }
            };
            console.log('üìÅ SQLite Fallback aktiviert');
        } catch (error) {
            console.log('‚ö†Ô∏è Memory Storage aktiviert');
            const memoryData = { plants: [], solar_panels: [], activity_logs: [], general_activities: [] };
            db = {
                query: async (text, params = []) => {
                    if (text.includes('CREATE TABLE')) return { rows: [] };
                    if (text.includes('INSERT')) {
                        const id = Math.floor(Math.random() * 1000) + 1;
                        return { rows: [{ id }] };
                    }
                    return { rows: [] };
                }
            };
        }
    }
}

// ===== HILFSFUNKTIONEN =====
const utils = {
    formatCurrency: (amount) => {
        return new Intl.NumberFormat('de-DE', {
            style: 'currency',
            currency: 'EUR',
            minimumFractionDigits: 0,
            maximumFractionDigits: 0
        }).format(amount);
    },
    
    formatDuration: (minutes) => {
        const hours = Math.floor(minutes / 60);
        const mins = minutes % 60;
        if (hours > 0) return `${hours}h ${mins}min`;
        return `${mins}min`;
    }
};

// ===== DATENBANK INITIALISIERUNG =====
async function initDatabase() {
    const queries = [
        // Bestehende Tabellen
        `CREATE TABLE IF NOT EXISTS plants (
            id SERIAL PRIMARY KEY,
            user_id TEXT NOT NULL,
            username TEXT NOT NULL,
            planted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            location TEXT NOT NULL,
            plant_type TEXT NOT NULL DEFAULT 'mandarinen',
            status TEXT DEFAULT 'planted',
            fertilized_by TEXT,
            fertilized_at TIMESTAMP,
            last_fertilizer_check TIMESTAMP,
            fertilizer_reminder_sent INTEGER DEFAULT 0,
            harvested_by TEXT,
            harvested_at TIMESTAMP,
            car_stored TEXT,
            server_id TEXT NOT NULL,
            experience_gained INTEGER DEFAULT 0,
            quality INTEGER DEFAULT 1,
            timer_paused_at TIMESTAMP,
            total_pause_duration INTEGER DEFAULT 0
        )`,
        
        `CREATE TABLE IF NOT EXISTS solar_panels (
            id SERIAL PRIMARY KEY,
            user_id TEXT NOT NULL,
            username TEXT NOT NULL,
            placed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            location TEXT NOT NULL,
            status TEXT DEFAULT 'active',
            repairs_count INTEGER DEFAULT 0,
            last_repair_at TIMESTAMP,
            last_repair_check TIMESTAMP,
            repair_reminder_sent INTEGER DEFAULT 0,
            collected_by TEXT,
            collected_at TIMESTAMP,
            car_stored TEXT,
            server_id TEXT NOT NULL,
            efficiency INTEGER DEFAULT 100,
            experience_gained INTEGER DEFAULT 0,
            timer_paused_at TIMESTAMP,
            total_pause_duration INTEGER DEFAULT 0
        )`,
        
        // NEUE TABELLE: Allgemeine Aktivit√§ten
        `CREATE TABLE IF NOT EXISTS general_activities (
            id SERIAL PRIMARY KEY,
            user_id TEXT NOT NULL,
            username TEXT NOT NULL,
            activity_type TEXT NOT NULL,
            location TEXT,
            participants TEXT,
            amount DECIMAL(12,2),
            details TEXT,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            server_id TEXT NOT NULL,
            verified_by TEXT,
            payout_amount DECIMAL(12,2)
        )`,
        
        // NEUE TABELLE: Rekrutierungen
        `CREATE TABLE IF NOT EXISTS recruitments (
            id SERIAL PRIMARY KEY,
            recruiter_id TEXT NOT NULL,
            recruiter_name TEXT NOT NULL,
            recruited_id TEXT,
            recruited_name TEXT NOT NULL,
            recruited_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            status TEXT DEFAULT 'active',
            week_completed BOOLEAN DEFAULT FALSE,
            payout_given BOOLEAN DEFAULT FALSE,
            server_id TEXT NOT NULL
        )`,
        
        // NEUE TABELLE: Externe Arbeiten
        `CREATE TABLE IF NOT EXISTS external_work (
            id SERIAL PRIMARY KEY,
            user_id TEXT NOT NULL,
            username TEXT NOT NULL,
            work_type TEXT NOT NULL,
            location TEXT NOT NULL,
            amount INTEGER DEFAULT 1,
            rate_per_unit DECIMAL(12,2),
            total_payout DECIMAL(12,2),
            details TEXT,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            server_id TEXT NOT NULL
        )`,
        
        // Erweiterte Activity Logs
        `CREATE TABLE IF NOT EXISTS activity_logs (
            id SERIAL PRIMARY KEY,
            user_id TEXT NOT NULL,
            username TEXT NOT NULL,
            action_type TEXT NOT NULL,
            item_type TEXT NOT NULL,
            item_id INTEGER,
            plant_type TEXT,
            location TEXT,
            details TEXT,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            server_id TEXT NOT NULL,
            experience INTEGER DEFAULT 0,
            reward DECIMAL(12,2) DEFAULT 0,
            activity_category TEXT DEFAULT 'farming'
        )`
    ];
    
    try {
        for (const query of queries) {
            await db.query(query);
        }
        console.log('‚úÖ Datenbank erfolgreich initialisiert (v3.0)');
        
        // Migration f√ºr neue Spalten
        try {
            await db.query('ALTER TABLE plants ADD COLUMN IF NOT EXISTS plant_type TEXT DEFAULT \'mandarinen\'');
            await db.query('ALTER TABLE plants ADD COLUMN IF NOT EXISTS timer_paused_at TIMESTAMP');
            await db.query('ALTER TABLE plants ADD COLUMN IF NOT EXISTS total_pause_duration INTEGER DEFAULT 0');
            
            await db.query('ALTER TABLE solar_panels ADD COLUMN IF NOT EXISTS timer_paused_at TIMESTAMP');
            await db.query('ALTER TABLE solar_panels ADD COLUMN IF NOT EXISTS total_pause_duration INTEGER DEFAULT 0');
            
            await db.query('ALTER TABLE activity_logs ADD COLUMN IF NOT EXISTS plant_type TEXT');
            await db.query('ALTER TABLE activity_logs ADD COLUMN IF NOT EXISTS reward DECIMAL(12,2) DEFAULT 0');
            await db.query('ALTER TABLE activity_logs ADD COLUMN IF NOT EXISTS activity_category TEXT DEFAULT \'farming\'');
            
            console.log('‚úÖ Datenbank-Migration v3.0 abgeschlossen');
        } catch (migrationError) {
            console.log('‚ö†Ô∏è Migration-Warnung:', migrationError.message);
        }
        
    } catch (error) {
        console.error('‚ùå Datenbank-Initialisierungsfehler:', error);
    }
}

// ===== BOT EVENTS =====
client.once('ready', async () => {
    console.log(`ü§ñ ${client.user.tag} ist online!`);
    console.log(`üá∑üá∫ Russkaya Familie Bot v3.0 - VOLLST√ÑNDIGES SYSTEM`);
    console.log(`üéØ Aktiv auf ${client.guilds.cache.size} Servern`);
    
    client.user.setActivity('Russkaya Familie v3.0 üá∑üá∫', { type: ActivityType.Watching });
    
    initializeDatabase();
    await initDatabase();
    await registerCommands();
    startBackgroundTasks();
    startHealthCheckServer();
});

// ===== COMMAND REGISTRATION =====
async function registerCommands() {
    const commands = [
        // ===== PFLANZEN COMMANDS =====
        new SlashCommandBuilder()
            .setName('pflanze-s√§en')
            .setDescription('üå± Eine neue Pflanze s√§en')
            .addStringOption(option =>
                option.setName('location')
                    .setDescription('Wo wurde die Pflanze ges√§t?')
                    .setRequired(true))
            .addStringOption(option =>
                option.setName('pflanzentyp')
                    .setDescription('Welche Pflanze m√∂chtest du s√§en?')
                    .setRequired(true)
                    .addChoices(
                        { name: 'üçä Mandarinen (3h, 800‚Ç¨)', value: 'mandarinen' },
                        { name: 'üçç Ananas (5h, 1500‚Ç¨)', value: 'ananas' },
                        { name: 'ü•¨ Kohl (2h, 500‚Ç¨)', value: 'kohl' }
                    )),

        new SlashCommandBuilder()
            .setName('pflanze-d√ºngen')
            .setDescription('üíö Eine Pflanze d√ºngen (Timer pausiert!)')
            .addIntegerOption(option =>
                option.setName('id')
                    .setDescription('ID der Pflanze')
                    .setRequired(true)),

        new SlashCommandBuilder()
            .setName('pflanze-ernten')
            .setDescription('üåø Eine Pflanze ernten')
            .addIntegerOption(option =>
                option.setName('id')
                    .setDescription('ID der Pflanze')
                    .setRequired(true))
            .addStringOption(option =>
                option.setName('car')
                    .setDescription('In welches Auto/Lager? (WICHTIG: Gallivanter f√ºr Auszahlung!)')
                    .setRequired(true)),

        new SlashCommandBuilder()
            .setName('pflanzen-status')
            .setDescription('üìã Alle aktiven Pflanzen anzeigen')
            .addStringOption(option =>
                option.setName('filter')
                    .setDescription('Nach Pflanzentyp filtern')
                    .addChoices(
                        { name: 'üçä Mandarinen', value: 'mandarinen' },
                        { name: 'üçç Ananas', value: 'ananas' },
                        { name: 'ü•¨ Kohl', value: 'kohl' },
                        { name: 'üìã Alle anzeigen', value: 'all' }
                    )),

        // ===== SOLAR COMMANDS =====
        new SlashCommandBuilder()
            .setName('solar-aufstellen')
            .setDescription('‚òÄÔ∏è Ein Solarpanel aufstellen')
            .addStringOption(option =>
                option.setName('location')
                    .setDescription('Wo wurde das Panel aufgestellt?')
                    .setRequired(true)),

        new SlashCommandBuilder()
            .setName('solar-reparieren')
            .setDescription('üîß Ein Solarpanel reparieren (Timer pausiert!)')
            .addIntegerOption(option =>
                option.setName('id')
                    .setDescription('ID des Solarpanels')
                    .setRequired(true)),

        new SlashCommandBuilder()
            .setName('solar-sammeln')
            .setDescription('üîã Batterie sammeln (WICHTIG: Gallivanter f√ºr Auszahlung!)')
            .addIntegerOption(option =>
                option.setName('id')
                    .setDescription('ID des Solarpanels')
                    .setRequired(true))
            .addStringOption(option =>
                option.setName('car')
                    .setDescription('Auto/Lager (Gallivanter = Auszahlung!)')
                    .setRequired(true)),

        new SlashCommandBuilder()
            .setName('solar-status')
            .setDescription('üìã Alle aktiven Solarpanels anzeigen'),

        // ===== NEUE AKTIVIT√ÑTEN COMMANDS =====
        new SlashCommandBuilder()
            .setName('aktivit√§t-eintragen')
            .setDescription('üìù Neue Aktivit√§t f√ºr Auszahlung eintragen')
            .addStringOption(option =>
                option.setName('typ')
                    .setDescription('Art der Aktivit√§t')
                    .setRequired(true)
                    .addChoices(
                        { name: 'üî´ Raid (10.000‚Ç¨ pro Person)', value: 'raid' },
                        { name: 'üö¢ Hafen Event (50.000‚Ç¨)', value: 'hafen_event' },
                        { name: '‚õ∞Ô∏è Mount Chiliad (30.000‚Ç¨)', value: 'mount_chiliad' },
                        { name: 'üè¨ EKZ (100.000‚Ç¨ pro Person)', value: 'ekz' },
                        { name: 'üè™ Shop Raub (~10.000‚Ç¨)', value: 'shop_raub' },
                        { name: '‚úàÔ∏è Flugzeugtr√§ger (20.000‚Ç¨)', value: 'flugzeugtraeger' },
                        { name: 'üîã Solar Abgabe (10.000‚Ç¨)', value: 'solar_abgabe' },
                        { name: 'üçÑ Pilzfarm (800‚Ç¨)', value: 'pilzfarm' }
                    ))
            .addStringOption(option =>
                option.setName('location')
                    .setDescription('Ort der Aktivit√§t')
                    .setRequired(true))
            .addStringOption(option =>
                option.setName('teilnehmer')
                    .setDescription('Teilnehmer (getrennt durch Komma)')
                    .setRequired(true))
            .addIntegerOption(option =>
                option.setName('betrag')
                    .setDescription('Individueller Betrag (falls abweichend)')
                    .setRequired(false)),

        // ===== EXTERNE ARBEITEN =====
        new SlashCommandBuilder()
            .setName('externe-arbeit')
            .setDescription('üåæ Externe Arbeiten eintragen (Beete d√ºngen, Solar reparieren)')
            .addStringOption(option =>
                option.setName('typ')
                    .setDescription('Art der Arbeit')
                    .setRequired(true)
                    .addChoices(
                        { name: 'üå± Beete d√ºngen (1.000‚Ç¨ pro Beet)', value: 'beete_duengen' },
                        { name: 'üîß Solar reparieren (1.000‚Ç¨ pro Reparatur)', value: 'solar_reparieren' }
                    ))
            .addStringOption(option =>
                option.setName('location')
                    .setDescription('Ort der Arbeit')
                    .setRequired(true))
            .addIntegerOption(option =>
                option.setName('anzahl')
                    .setDescription('Anzahl (Beete/Reparaturen)')
                    .setRequired(true))
            .addStringOption(option =>
                option.setName('details')
                    .setDescription('Zus√§tzliche Details')
                    .setRequired(false)),

        // ===== REKRUTIERUNG =====
        new SlashCommandBuilder()
            .setName('rekrutierung')
            .setDescription('üë• Neue Rekrutierung eintragen')
            .addStringOption(option =>
                option.setName('neuer_spieler')
                    .setDescription('Name des neuen Spielers')
                    .setRequired(true))
            .addUserOption(option =>
                option.setName('discord_user')
                    .setDescription('Discord User (falls verf√ºgbar)')
                    .setRequired(false)),

        new SlashCommandBuilder()
            .setName('rekrutierung-abschlie√üen')
            .setDescription('‚úÖ Rekrutierung nach 1 Woche abschlie√üen (20.000‚Ç¨)')
            .addIntegerOption(option =>
                option.setName('id')
                    .setDescription('Rekrutierungs-ID')
                    .setRequired(true)),

        // ===== INFO & UTILITY =====
        new SlashCommandBuilder()
            .setName('aktivit√§ten-info')
            .setDescription('‚ÑπÔ∏è Alle verf√ºgbaren Aktivit√§ten und Auszahlungen'),

        new SlashCommandBuilder()
            .setName('meine-aktivit√§ten')
            .setDescription('üìä Deine Aktivit√§ten heute/diese Woche')
            .addStringOption(option =>
                option.setName('zeitraum')
                    .setDescription('Zeitraum ausw√§hlen')
                    .addChoices(
                        { name: 'üìÖ Heute', value: 'today' },
                        { name: 'üìÜ Diese Woche', value: 'week' },
                        { name: 'üóìÔ∏è Dieser Monat', value: 'month' }
                    )),

        new SlashCommandBuilder()
            .setName('pflanzen-info')
            .setDescription('‚ÑπÔ∏è Informationen √ºber alle Pflanzentypen'),

        new SlashCommandBuilder()
            .setName('backup')
            .setDescription('üíæ Daten-Backup erstellen (Admin only)')
            .setDefaultMemberPermissions(PermissionFlagsBits.Administrator)
            .addStringOption(option =>
                option.setName('format')
                    .setDescription('Backup-Format')
                    .addChoices(
                        { name: 'CSV (Standard)', value: 'csv' },
                        { name: 'JSON (Auszahlungen)', value: 'json' },
                        { name: 'Vollst√§ndig (Alle Tabellen)', value: 'complete' }
                    )),

        new SlashCommandBuilder()
            .setName('help')
            .setDescription('‚ùì Hilfe und Befehls-√úbersicht'),

        new SlashCommandBuilder()
            .setName('statistiken')
            .setDescription('üìä Umfassende Server-Statistiken')
    ];

    try {
        console.log('üìù Registriere Slash Commands v3.0...');
        await client.application.commands.set(commands);
        console.log(`‚úÖ ${commands.length} Commands erfolgreich registriert!`);
    } catch (error) {
        console.error('‚ùå Fehler beim Registrieren der Commands:', error);
    }
}

// ===== COMMAND HANDLERS =====
client.on('interactionCreate', async (interaction) => {
    if (!interaction.isChatInputCommand()) return;

    const { commandName } = interaction;

    try {
        switch (commandName) {
            // Bestehende Commands
            case 'pflanze-s√§en':
                await handlePlantSeed(interaction);
                break;
            case 'pflanze-d√ºngen':
                await handlePlantFertilize(interaction);
                break;
            case 'pflanze-ernten':
                await handlePlantHarvest(interaction);
                break;
            case 'pflanzen-status':
                await handlePlantsStatus(interaction);
                break;
            case 'pflanzen-info':
                await handlePlantsInfo(interaction);
                break;
            case 'solar-aufstellen':
                await handleSolarPlace(interaction);
                break;
            case 'solar-reparieren':
                await handleSolarRepair(interaction);
                break;
            case 'solar-sammeln':
                await handleSolarCollect(interaction);
                break;
            case 'solar-status':
                await handleSolarStatus(interaction);
                break;
            
            // Neue Commands
            case 'aktivit√§t-eintragen':
                await handleActivityEntry(interaction);
                break;
            case 'externe-arbeit':
                await handleExternalWork(interaction);
                break;
            case 'rekrutierung':
                await handleRecruitment(interaction);
                break;
            case 'rekrutierung-abschlie√üen':
                await handleRecruitmentComplete(interaction);
                break;
            case 'aktivit√§ten-info':
                await handleActivitiesInfo(interaction);
                break;
            case 'meine-aktivit√§ten':
                await handleMyActivities(interaction);
                break;
            
            // System Commands
            case 'backup':
                await handleBackup(interaction);
                break;
            case 'help':
                await handleHelp(interaction);
                break;
            case 'statistiken':
                await handleStatistics(interaction);
                break;
            default:
                await interaction.reply({ 
                    content: '‚ùå Unbekannter Command!', 
                    ephemeral: true 
                });
        }
    } catch (error) {
        console.error(`‚ùå Command Error (${commandName}):`, error);
        
        const errorMessage = 'Es ist ein Fehler aufgetreten! Bitte versuche es erneut.';
        
        if (!interaction.replied && !interaction.deferred) {
            await interaction.reply({ content: errorMessage, ephemeral: true });
        } else if (interaction.deferred) {
            await interaction.followUp({ content: errorMessage, ephemeral: true });
        }
    }
});

// ===== PFLANZEN HANDLERS =====
async function handlePlantsInfo(interaction) {
    const embed = new EmbedBuilder()
        .setColor('#32CD32')
        .setTitle('üå± Pflanzen-Informationen')
        .setDescription('Alle verf√ºgbaren Pflanzentypen und ihre Eigenschaften')
        .setFooter({ text: 'Russkaya Familie üá∑üá∫ ‚Ä¢ W√§hle weise!' })
        .setTimestamp();

    Object.entries(PLANT_TYPES).forEach(([key, plant]) => {
        embed.addFields({
            name: `${plant.emoji} ${plant.name}`,
            value: `‚è∞ **Wachstumszeit:** ${utils.formatDuration(plant.growthTime)}\nüí∞ **Ertrag:** ${utils.formatCurrency(plant.baseReward)}\nüí∏ **Saatgut-Kosten:** ${utils.formatCurrency(plant.seedCost)}\nüìù **Besonderheit:** ${plant.description}\nüíö **D√ºnger-Erinnerungen:** ${plant.fertilizeTime1}min & ${plant.fertilizeTime2}min`,
            inline: true
        });
    });

    embed.addFields({
        name: 'üí° Timer-Mechanik & Gallivanter-Regel',
        value: '**‚ö†Ô∏è WICHTIG:** Timer pausiert wenn du nicht d√ºngst!\n**üöó AUSZAHLUNG:** Ernte in **Gallivanter-Kofferaum** legen!\n‚Ä¢ Ohne D√ºngung: Timer l√§uft weiter\n‚Ä¢ Mit D√ºngung: Timer pausiert bis zur n√§chsten Aktion\n‚Ä¢ Rechtzeitig d√ºngen = Optimale Wachstumszeit!',
        inline: false
    });

    await interaction.reply({ embeds: [embed] });
}

async function handlePlantSeed(interaction) {
    const location = interaction.options.getString('location').trim();
    const plantType = interaction.options.getString('pflanzentyp');
    const userId = interaction.user.id;
    const username = interaction.user.displayName || interaction.user.username;
    const serverId = interaction.guildId;

    await interaction.deferReply();

    if (!PLANT_TYPES[plantType]) {
        await interaction.followUp('‚ùå Unbekannter Pflanzentyp!');
        return;
    }

    const plant = PLANT_TYPES[plantType];

    try {
        const { rows } = await db.query(`
            INSERT INTO plants (user_id, username, location, plant_type, server_id)
            VALUES ($1, $2, $3, $4, $5)
            RETURNING id, planted_at
        `, [userId, username, location, plantType, serverId]);

        const plantId = rows[0]?.id || Math.floor(Math.random() * 1000) + 1;

        await logActivity(userId, username, 'PLANTED', 'PLANT', plantId, location, null, serverId, 50, 0, plantType, 'farming');

        const harvestTime = Math.floor((Date.now() + plant.growthTime * 60 * 1000) / 1000);

        const embed = new EmbedBuilder()
            .setColor('#00ff00')
            .setTitle(`${plant.emoji} Pflanze erfolgreich ges√§t!`)
            .setDescription(`Deine **${plant.name}** w√§chst nun heran!`)
            .addFields(
                { name: 'üë§ Ges√§t von', value: username, inline: true },
                { name: 'üìç Standort', value: `\`${location}\``, inline: true },
                { name: 'üÜî Pflanzen-ID', value: `**#${plantId}**`, inline: true },
                { name: 'üå± Pflanzentyp', value: `${plant.emoji} **${plant.name}**`, inline: true },
                { name: '‚è∞ Wachstumszeit', value: `**${utils.formatDuration(plant.growthTime)}**`, inline: true },
                { name: 'üí∞ Erwarteter Ertrag', value: `**${utils.formatCurrency(plant.baseReward)}**`, inline: true },
                { name: 'üåø Erntereif', value: `<t:${harvestTime}:R>`, inline: true },
                { name: '‚≠ê Erfahrung erhalten', value: `**+50 XP**`, inline: true }
            )
            .setFooter({ text: `Russkaya Familie üá∑üá∫ ‚Ä¢ ${plant.description}` })
            .setTimestamp();

        embed.addFields({
            name: 'üöó WICHTIGE AUSZAHLUNGS-REGEL',
            value: '**F√ºr Auszahlung:** Ernte in **Gallivanter-Kofferaum** legen!\n‚è∏Ô∏è Timer pausiert automatisch wenn du d√ºngst\nüíö D√ºnge zur richtigen Zeit f√ºr optimale Ertr√§ge',
            inline: false
        });

        await interaction.followUp({ embeds: [embed] });

    } catch (error) {
        console.error('‚ùå Plant Seed Error:', error);
        await interaction.followUp('‚ùå Fehler beim S√§en der Pflanze!');
    }
}

async function handlePlantFertilize(interaction) {
    const plantId = interaction.options.getInteger('id');
    const userId = interaction.user.id;
    const username = interaction.user.displayName || interaction.user.username;
    const serverId = interaction.guildId;

    await interaction.deferReply();

    try {
        const { rows: plantRows } = await db.query(`
            SELECT *, 
                   EXTRACT(EPOCH FROM (NOW() - planted_at)) / 60 as minutes_since_planted
            FROM plants 
            WHERE id = $1 AND server_id = $2 AND status = 'planted'
        `, [plantId, serverId]);

        if (plantRows.length === 0) {
            await interaction.followUp('‚ùå Pflanze nicht gefunden oder bereits geerntet!');
            return;
        }

        const plantData = plantRows[0];
        const plant = PLANT_TYPES[plantData.plant_type];

        if (!plant) {
            await interaction.followUp('‚ùå Unbekannter Pflanzentyp!');
            return;
        }

        if (plantData.fertilized_by) {
            await interaction.followUp('‚ùå Diese Pflanze wurde bereits ged√ºngt!');
            return;
        }

        const minutesSincePlanted = plantData.minutes_since_planted || 0;
        const canFertilizeNow = minutesSincePlanted >= plant.fertilizeTime1;

        if (!canFertilizeNow) {
            const waitTime = Math.ceil(plant.fertilizeTime1 - minutesSincePlanted);
            await interaction.followUp(`‚ùå Noch zu fr√ºh zum D√ºngen! Warte noch **${utils.formatDuration(waitTime)}**`);
            return;
        }

        await db.query(`
            UPDATE plants 
            SET fertilized_by = $1, fertilized_at = NOW(), quality = quality + 1,
                timer_paused_at = NOW(), last_fertilizer_check = NOW()
            WHERE id = $2
        `, [username, plantId]);

        const isOwnPlant = plantData.user_id === userId;
        const experience = isOwnPlant ? 30 : 50;

        await logActivity(userId, username, 'FERTILIZED', 'PLANT', plantId, plantData.location, 
                         isOwnPlant ? 'Eigene Pflanze' : `Pflanze von ${plantData.username}`, serverId, experience, 0, plantData.plant_type, 'farming');

        const embed = new EmbedBuilder()
            .setColor('#32CD32')
            .setTitle(`üíö ${plant.emoji} Pflanze erfolgreich ged√ºngt!`)
            .setDescription(isOwnPlant ? 'Du hast deine eigene Pflanze ged√ºngt!' : 'Du hast einer Familien-Pflanze geholfen!')
            .addFields(
                { name: 'üë§ Ged√ºngt von', value: username, inline: true },
                { name: 'üÜî Pflanzen-ID', value: `**#${plantId}**`, inline: true },
                { name: 'üå± Pflanzentyp', value: `${plant.emoji} **${plant.name}**`, inline: true },
                { name: 'üìç Standort', value: `\`${plantData.location}\``, inline: true },
                { name: 'üå± Urspr√ºnglich ges√§t von', value: plantData.username, inline: true },
                { name: '‚≠ê Erfahrung erhalten', value: `**+${experience} XP**${!isOwnPlant ? ' (Teamwork Bonus!)' : ''}`, inline: true },
                { name: 'üéÅ Ertragssteigerung', value: '**+25%** beim Ernten', inline: true },
                { name: '‚è∏Ô∏è Timer-Status', value: '**PAUSIERT** bis zur n√§chsten Aktion', inline: true }
            )
            .setFooter({ text: 'Russkaya Familie üá∑üá∫ ‚Ä¢ Timer pausiert automatisch!' })
            .setTimestamp();

        await interaction.followUp({ embeds: [embed] });

    } catch (error) {
        console.error('‚ùå Plant Fertilize Error:', error);
        await interaction.followUp('‚ùå Fehler beim D√ºngen der Pflanze!');
    }
}

async function handlePlantHarvest(interaction) {
    const plantId = interaction.options.getInteger('id');
    const car = interaction.options.getString('car').trim();
    const userId = interaction.user.id;
    const username = interaction.user.displayName || interaction.user.username;
    const serverId = interaction.guildId;

    await interaction.deferReply();

    try {
        const { rows: plantRows } = await db.query(`
            SELECT *, 
                   EXTRACT(EPOCH FROM (NOW() - planted_at)) / 60 as minutes_since_planted
            FROM plants 
            WHERE id = $1 AND server_id = $2 AND status = 'planted'
        `, [plantId, serverId]);

        if (plantRows.length === 0) {
            await interaction.followUp('‚ùå Pflanze nicht gefunden oder bereits geerntet!');
            return;
        }

        const plantData = plantRows[0];
        const plant = PLANT_TYPES[plantData.plant_type];

        if (!plant) {
            await interaction.followUp('‚ùå Unbekannter Pflanzentyp!');
            return;
        }

        const minutesSincePlanted = plantData.minutes_since_planted || 0;
        if (minutesSincePlanted < plant.growthTime) {
            const remainingMinutes = Math.ceil(plant.growthTime - minutesSincePlanted);
            await interaction.followUp(`‚ùå Pflanze ist noch nicht erntereif! Noch **${utils.formatDuration(remainingMinutes)}** warten.`);
            return;
        }

        const baseReward = plant.baseReward;
        const fertilizedBonus = plantData.fertilized_by ? baseReward * 0.25 : 0;
        const totalReward = Math.floor(baseReward + fertilizedBonus);

        const isOwnPlant = plantData.user_id === userId;
        const experience = isOwnPlant ? 100 : 75;

        await db.query(`
            UPDATE plants 
            SET status = 'harvested', harvested_by = $1, harvested_at = NOW(), 
                car_stored = $2, experience_gained = $3
            WHERE id = $4
        `, [username, car, experience, plantId]);

        await logActivity(userId, username, 'HARVESTED', 'PLANT', plantId, plantData.location, 
                         `Auto: ${car}, Ertrag: ${utils.formatCurrency(totalReward)}${!isOwnPlant ? `, Pflanze von ${plantData.username}` : ''}`, 
                         serverId, experience, totalReward, plantData.plant_type, 'farming');

        const embed = new EmbedBuilder()
            .setColor('#228B22')
            .setTitle(`üåø ${plant.emoji} Pflanze erfolgreich geerntet!`)
            .setDescription(isOwnPlant ? 'Du hast deine eigene Pflanze geerntet!' : 'Du hast eine Familien-Pflanze geerntet!')
            .addFields(
                { name: 'üë§ Geerntet von', value: username, inline: true },
                { name: 'üÜî Pflanzen-ID', value: `**#${plantId}**`, inline: true },
                { name: 'üå± Pflanzentyp', value: `${plant.emoji} **${plant.name}**`, inline: true },
                { name: 'üöó Verstaut in', value: `\`${car}\``, inline: true },
                { name: 'üìç Standort', value: `\`${plantData.location}\``, inline: true },
                { name: 'üå± Urspr√ºnglich ges√§t von', value: plantData.username, inline: true },
                { name: 'üíö Ged√ºngt', value: plantData.fertilized_by ? `‚úÖ von ${plantData.fertilized_by}` : '‚ùå Nicht ged√ºngt', inline: true },
                { name: 'üí∞ Ertrag', value: `**${utils.formatCurrency(totalReward)}**`, inline: true },
                { name: '‚≠ê Erfahrung', value: `**+${experience} XP**`, inline: true }
            )
            .setFooter({ text: 'Russkaya Familie üá∑üá∫ ‚Ä¢ Erfolgreiche Ernte!' })
            .setTimestamp();

        if (plantData.fertilized_by) {
            embed.addFields({ 
                name: 'üéÅ D√ºnger-Bonus', 
                value: `**${utils.formatCurrency(fertilizedBonus)}** (+25%)`, 
                inline: true 
            });
        }

        if (car.toLowerCase().includes('gallivanter')) {
            embed.addFields({
                name: 'üöó GALLIVANTER ERKANNT!',
                value: '‚úÖ **Qualifiziert f√ºr Auszahlung!**\nDiese Ernte wird in der t√§glichen Auszahlungsberechnung erfasst.',
                inline: false
            });
        }

        await interaction.followUp({ embeds: [embed] });

    } catch (error) {
        console.error('‚ùå Plant Harvest Error:', error);
        await interaction.followUp('‚ùå Fehler beim Ernten der Pflanze!');
    }
}

async function handlePlantsStatus(interaction) {
    const serverId = interaction.guildId;
    const filter = interaction.options.getString('filter') || 'all';
    await interaction.deferReply();

    try {
        let whereClause = 'WHERE server_id = $1 AND status = \'planted\'';
        let params = [serverId];
        
        if (filter !== 'all') {
            whereClause += ' AND plant_type = $2';
            params.push(filter);
        }

        const { rows: plants } = await db.query(`
            SELECT *,
                   EXTRACT(EPOCH FROM (NOW() - planted_at)) / 60 as minutes_since_planted
            FROM plants
            ${whereClause}
            ORDER BY planted_at DESC
            LIMIT 10
        `, params);

        const filterName = filter === 'all' ? 'Alle Pflanzen' : `${PLANT_TYPES[filter]?.emoji} ${PLANT_TYPES[filter]?.name}`;

        const embed = new EmbedBuilder()
            .setColor('#00AA00')
            .setTitle(`üå± Aktive Pflanzen - ${filterName}`)
            .setDescription(`**${plants.length}** aktive Pflanzen gefunden`)
            .setFooter({ text: 'Russkaya Familie üá∑üá∫ ‚Ä¢ ‚è∏Ô∏è = Timer pausiert' })
            .setTimestamp();

        if (plants.length === 0) {
            embed.setDescription(`Keine aktiven Pflanzen vorhanden ${filter !== 'all' ? `(${filterName})` : ''}.`);
            await interaction.followUp({ embeds: [embed] });
            return;
        }

        plants.forEach((plantData, index) => {
            if (index >= 8) return;

            const plant = PLANT_TYPES[plantData.plant_type];
            if (!plant) return;

            const minutesSincePlanted = plantData.minutes_since_planted || 0;
            const isReady = minutesSincePlanted >= plant.growthTime;
            const isPaused = plantData.timer_paused_at !== null;
            
            let status = '';
            if (isReady) {
                status = 'üåø **ERNTEREIF**';
            } else if (isPaused) {
                status = '‚è∏Ô∏è **PAUSIERT** (d√ºngen um fortzusetzen)';
            } else {
                const remainingMinutes = Math.ceil(plant.growthTime - minutesSincePlanted);
                status = `‚è∞ Noch ${utils.formatDuration(remainingMinutes)}`;
            }

            const fertilizerStatus = plantData.fertilized_by ? `‚úÖ Ged√ºngt von ${plantData.fertilized_by}` : '‚ùå Nicht ged√ºngt';

            embed.addFields({
                name: `${plant.emoji} Pflanze #${plantData.id} - ${plantData.location}`,
                value: `üë§ **${plantData.username}** ‚Ä¢ ${status}\nüíö ${fertilizerStatus}`,
                inline: true
            });
        });

        await interaction.followUp({ embeds: [embed] });

    } catch (error) {
        console.error('‚ùå Plants Status Error:', error);
        await interaction.followUp('‚ùå Fehler beim Abrufen der Pflanzen!');
    }
}

// ===== SOLAR HANDLERS =====
async function handleSolarPlace(interaction) {
    const location = interaction.options.getString('location').trim();
    const userId = interaction.user.id;
    const username = interaction.user.displayName || interaction.user.username;
    const serverId = interaction.guildId;

    await interaction.deferReply();

    try {
        const { rows } = await db.query(`
            INSERT INTO solar_panels (user_id, username, location, server_id)
            VALUES ($1, $2, $3, $4)
            RETURNING id, placed_at
        `, [userId, username, location, serverId]);

        const solarId = rows[0]?.id || Math.floor(Math.random() * 1000) + 1;
        
        await logActivity(userId, username, 'PLACED', 'SOLAR', solarId, location, null, serverId, 75, 0, null, 'farming');

        const batteryTime = Math.floor((Date.now() + config.timers.solarBatteryTime * 60 * 1000) / 1000);

        const embed = new EmbedBuilder()
            .setColor('#FFD700')
            .setTitle('‚òÄÔ∏è Solarpanel erfolgreich aufgestellt!')
            .setDescription('Das Panel sammelt nun Sonnenenergie!')
            .addFields(
                { name: 'üë§ Aufgestellt von', value: username, inline: true },
                { name: 'üìç Standort', value: `\`${location}\``, inline: true },
                { name: 'üÜî Panel-ID', value: `**#${solarId}**`, inline: true },
                { name: 'üîß Reparaturen', value: '**0/4**', inline: true },
                { name: 'üîã Batterie bereit', value: `<t:${batteryTime}:R>`, inline: true },
                { name: '‚≠ê Erfahrung erhalten', value: `**+75 XP**`, inline: true }
            )
            .setFooter({ text: 'Russkaya Familie üá∑üá∫ ‚Ä¢ 4 Reparaturen = 1 Batterie!' })
            .setTimestamp();

        embed.addFields({
            name: '‚ö†Ô∏è NEUE TIMER-MECHANIK',
            value: 'üîÑ Timer pausiert automatisch wenn du nicht reparierst!\nüí° Repariere zur richtigen Zeit f√ºr optimale Effizienz',
            inline: false
        });

        await interaction.followUp({ embeds: [embed] });

    } catch (error) {
        console.error('‚ùå Solar Place Error:', error);
        await interaction.followUp('‚ùå Fehler beim Aufstellen des Solarpanels!');
    }
}

async function handleSolarRepair(interaction) {
    const solarId = interaction.options.getInteger('id');
    const userId = interaction.user.id;
    const username = interaction.user.displayName || interaction.user.username;
    const serverId = interaction.guildId;

    await interaction.deferReply();

    try {
        const { rows: panelRows } = await db.query(`
            SELECT *,
                   EXTRACT(EPOCH FROM (NOW() - placed_at)) / 60 as minutes_since_placed
            FROM solar_panels 
            WHERE id = $1 AND server_id = $2 AND status = 'active'
        `, [solarId, serverId]);

        if (panelRows.length === 0) {
            await interaction.followUp('‚ùå Solarpanel nicht gefunden oder bereits eingesammelt!');
            return;
        }

        const panel = panelRows[0];

        if (panel.repairs_count >= 4) {
            await interaction.followUp('‚ùå Dieses Panel wurde bereits 4x repariert! Batterie kann eingesammelt werden.');
            return;
        }

        const newRepairCount = panel.repairs_count + 1;

        await db.query(`
            UPDATE solar_panels 
            SET repairs_count = $1, last_repair_at = NOW(), timer_paused_at = NOW(),
                last_repair_check = NOW()
            WHERE id = $2
        `, [newRepairCount, solarId]);

        const isOwnPanel = panel.user_id === userId;
        const experience = isOwnPanel ? 40 : 60;

        await logActivity(userId, username, 'REPAIRED', 'SOLAR', solarId, panel.location, 
                         `Reparatur ${newRepairCount}/4${!isOwnPanel ? `, Panel von ${panel.username}` : ''}`, serverId, experience, 0, null, 'farming');

        const isReadyForBattery = newRepairCount >= 4;

        const embed = new EmbedBuilder()
            .setColor(isReadyForBattery ? '#00FF00' : '#FFA500')
            .setTitle(isReadyForBattery ? 'üîã Panel bereit f√ºr Batterie-Entnahme!' : 'üîß Solarpanel repariert!')
            .setDescription(isReadyForBattery ? 'Das Panel kann jetzt eine Batterie produzieren!' : 'Eine weitere Reparatur durchgef√ºhrt!')
            .addFields(
                { name: 'üë§ Repariert von', value: username, inline: true },
                { name: 'üÜî Panel-ID', value: `**#${solarId}**`, inline: true },
                { name: 'üîß Reparaturen', value: `**${newRepairCount}/4**`, inline: true },
                { name: 'üìç Standort', value: `\`${panel.location}\``, inline: true },
                { name: '‚òÄÔ∏è Aufgestellt von', value: panel.username, inline: true },
                { name: '‚≠ê Erfahrung', value: `**+${experience} XP**${!isOwnPanel ? ' (Teamwork!)' : ''}`, inline: true },
                { name: '‚è∏Ô∏è Timer-Status', value: '**PAUSIERT** bis zur n√§chsten Aktion', inline: true }
            )
            .setFooter({ text: 'Russkaya Familie üá∑üá∫ ‚Ä¢ Timer pausiert automatisch!' })
            .setTimestamp();

        if (isReadyForBattery) {
            embed.addFields({
                name: '‚ö° N√§chster Schritt',
                value: `Verwende \`/solar-sammeln id:${solarId}\` um die Batterie zu sammeln!`,
                inline: false
            });
        } else {
            embed.addFields({
                name: 'üîÑ Noch ben√∂tigt',
                value: `**${4 - newRepairCount}** weitere Reparaturen`,
                inline: false
            });
        }

        await interaction.followUp({ embeds: [embed] });

    } catch (error) {
        console.error('‚ùå Solar Repair Error:', error);
        await interaction.followUp('‚ùå Fehler beim Reparieren des Solarpanels!');
    }
}

async function handleSolarCollect(interaction) {
    const solarId = interaction.options.getInteger('id');
    const car = interaction.options.getString('car').trim();
    const userId = interaction.user.id;
    const username = interaction.user.displayName || interaction.user.username;
    const serverId = interaction.guildId;

    await interaction.deferReply();

    try {
        const { rows: panelRows } = await db.query(`
            SELECT *,
                   EXTRACT(EPOCH FROM (NOW() - placed_at)) / 60 as minutes_active
            FROM solar_panels 
            WHERE id = $1 AND server_id = $2 AND status = 'active'
        `, [solarId, serverId]);

        if (panelRows.length === 0) {
            await interaction.followUp('‚ùå Solarpanel nicht gefunden oder bereits eingesammelt!');
            return;
        }

        const panel = panelRows[0];

        if (panel.repairs_count < 4) {
            await interaction.followUp(`‚ùå Panel noch nicht bereit! Ben√∂tigt noch **${4 - panel.repairs_count}** Reparaturen.`);
            return;
        }

        const minutesActive = panel.minutes_active || 0;
        if (minutesActive < config.timers.solarBatteryTime) {
            const remainingMinutes = Math.ceil(config.timers.solarBatteryTime - minutesActive);
            await interaction.followUp(`‚ùå Batterie noch nicht bereit! Noch **${utils.formatDuration(remainingMinutes)}** warten.`);
            return;
        }

        const totalReward = 800;
        const isOwnPanel = panel.user_id === userId;
        const experience = isOwnPanel ? 120 : 90;

        await db.query(`
            UPDATE solar_panels 
            SET status = 'collected', collected_by = $1, collected_at = NOW(), 
                car_stored = $2, experience_gained = $3
            WHERE id = $4
        `, [username, car, experience, solarId]);

        await logActivity(userId, username, 'COLLECTED', 'SOLAR', solarId, panel.location, 
                         `Auto: ${car}, Ertrag: ${utils.formatCurrency(totalReward)}${!isOwnPanel ? `, Panel von ${panel.username}` : ''}`, 
                         serverId, experience, totalReward, null, 'farming');

        const embed = new EmbedBuilder()
            .setColor('#32CD32')
            .setTitle('üîã Batterie erfolgreich eingesammelt!')
            .setDescription(isOwnPanel ? 'Du hast deine eigene Solar-Batterie eingesammelt!' : 'Du hast eine Familien-Batterie eingesammelt!')
            .addFields(
                { name: 'üë§ Eingesammelt von', value: username, inline: true },
                { name: 'üÜî Panel-ID', value: `**#${solarId}**`, inline: true },
                { name: 'üöó Verstaut in', value: `\`${car}\``, inline: true },
                { name: 'üìç Standort', value: `\`${panel.location}\``, inline: true },
                { name: '‚òÄÔ∏è Aufgestellt von', value: panel.username, inline: true },
                { name: 'üîß Reparaturen', value: `**${panel.repairs_count}/4** ‚úÖ`, inline: true },
                { name: 'üí∞ Ertrag', value: `**${utils.formatCurrency(totalReward)}**`, inline: true },
                { name: '‚≠ê Erfahrung', value: `**+${experience} XP**`, inline: true }
            )
            .setFooter({ text: 'Russkaya Familie üá∑üá∫ ‚Ä¢ Erfolgreiche Sammlung!' })
            .setTimestamp();

        if (car.toLowerCase().includes('gallivanter')) {
            embed.addFields({
                name: 'üöó GALLIVANTER ERKANNT!',
                value: '‚úÖ **Qualifiziert f√ºr Auszahlung!**\nDiese Batterie wird in der t√§glichen Auszahlungsberechnung erfasst.',
                inline: false
            });
        }

        await interaction.followUp({ embeds: [embed] });

    } catch (error) {
        console.error('‚ùå Solar Collect Error:', error);
        await interaction.followUp('‚ùå Fehler beim Sammeln der Batterie!');
    }
}

async function handleSolarStatus(interaction) {
    const serverId = interaction.guildId;
    await interaction.deferReply();

    try {
        const { rows: panels } = await db.query(`
            SELECT *,
                   EXTRACT(EPOCH FROM (NOW() - placed_at)) / 60 as minutes_active
            FROM solar_panels
            WHERE server_id = $1 AND status = 'active'
            ORDER BY placed_at DESC
            LIMIT 10
        `, [serverId]);

        const embed = new EmbedBuilder()
            .setColor('#FFD700')
            .setTitle('‚òÄÔ∏è Aktive Solarpanels')
            .setDescription(`**${panels.length}** aktive Panels gefunden`)
            .setFooter({ text: 'Russkaya Familie üá∑üá∫ ‚Ä¢ ‚è∏Ô∏è = Timer pausiert' })
            .setTimestamp();

        if (panels.length === 0) {
            embed.setDescription('Keine aktiven Solarpanels vorhanden.');
            await interaction.followUp({ embeds: [embed] });
            return;
        }

        panels.forEach((panel, index) => {
            if (index >= 6) return;

            const minutesActive = panel.minutes_active || 0;
            const isTimeReady = minutesActive >= config.timers.solarBatteryTime;
            const isRepairReady = panel.repairs_count >= 4;
            const isPaused = panel.timer_paused_at !== null;

            let status = '';
            if (isRepairReady && isTimeReady) {
                status = 'üîã **BATTERIE BEREIT**';
            } else if (isRepairReady && isPaused) {
                status = '‚è∏Ô∏è **PAUSIERT** (reparieren um fortzusetzen)';
            } else if (isRepairReady) {
                const remainingMinutes = Math.ceil(config.timers.solarBatteryTime - minutesActive);
                status = `‚è∞ Noch ${utils.formatDuration(remainingMinutes)}`;
            } else {
                status = `üîß ${panel.repairs_count}/4 Reparaturen`;
            }

            embed.addFields({
                name: `‚òÄÔ∏è Panel #${panel.id} - ${panel.location}`,
                value: `üë§ **${panel.username}** ‚Ä¢ ${status}`,
                inline: true
            });
        });

        await interaction.followUp({ embeds: [embed] });

    } catch (error) {
        console.error('‚ùå Solar Status Error:', error);
        await interaction.followUp('‚ùå Fehler beim Abrufen der Solarpanels!');
    }
}

// ===== NEUE AKTIVIT√ÑTEN HANDLERS =====
async function handleActivitiesInfo(interaction) {
    const embed = new EmbedBuilder()
        .setColor('#FFD700')
        .setTitle('üìã Russkaya Familie - Alle Aktivit√§ten & Auszahlungen')
        .setDescription('**Vollst√§ndige √úbersicht aller verf√ºgbaren Aktivit√§ten**')
        .setFooter({ text: 'Russkaya Familie üá∑üá∫ ‚Ä¢ v3.0 Vollsystem' })
        .setTimestamp();

    // Raids & Events
    embed.addFields({
        name: 'üî´ Raids & Events',
        value: `${ACTIVITY_TYPES.raid.emoji} **Raid:** ${utils.formatCurrency(ACTIVITY_TYPES.raid.reward)} pro Person\n${ACTIVITY_TYPES.hafen_event.emoji} **Hafen Event:** ${utils.formatCurrency(ACTIVITY_TYPES.hafen_event.reward)} pro Container\n${ACTIVITY_TYPES.mount_chiliad.emoji} **Mount Chiliad:** ${utils.formatCurrency(ACTIVITY_TYPES.mount_chiliad.reward)} pro Abgabe\n${ACTIVITY_TYPES.ekz.emoji} **EKZ:** ${utils.formatCurrency(ACTIVITY_TYPES.ekz.reward)} pro Person\n${ACTIVITY_TYPES.shop_raub.emoji} **Shop Raub:** ~${utils.formatCurrency(ACTIVITY_TYPES.shop_raub.reward)} pro Person\n${ACTIVITY_TYPES.flugzeugtraeger.emoji} **Flugzeugtr√§ger:** ${utils.formatCurrency(ACTIVITY_TYPES.flugzeugtraeger.reward)} pro Drop`,
        inline: true
    });

    embed.addFields({
        name: 'üåæ Farming & Solar',
        value: `üå± **Beete d√ºngen:** ${utils.formatCurrency(PAYOUT_RATES.BEETE_DUENGEN)} pro Beet\nüîß **Solar reparieren:** ${utils.formatCurrency(PAYOUT_RATES.SOLAR_REPARIEREN)} pro Reparatur\n${ACTIVITY_TYPES.solar_abgabe.emoji} **Solar Abgabe:** ${utils.formatCurrency(ACTIVITY_TYPES.solar_abgabe.reward)} pro Batterie\n${ACTIVITY_TYPES.pilzfarm.emoji} **Pilzfarm:** ${utils.formatCurrency(ACTIVITY_TYPES.pilzfarm.reward)} pro Abgabe`,
        inline: true
    });

    embed.addFields({
        name: 'üí∏ Passive & Andere',
        value: `${ACTIVITY_TYPES.gelddruckmaschine.emoji} **Gelddruckmaschine:** ${utils.formatCurrency(ACTIVITY_TYPES.gelddruckmaschine.reward)} alle 5 Min\n${ACTIVITY_TYPES.recruitment.emoji} **Rekrutierung:** ${utils.formatCurrency(ACTIVITY_TYPES.recruitment.reward)} pro Person (1+ Woche)`,
        inline: true
    });

    embed.addFields({
        name: 'üçä Pflanzen-System',
        value: `**Mandarinen** (3h): ${utils.formatCurrency(PLANT_TYPES.mandarinen.baseReward)}\n**Ananas** (5h): ${utils.formatCurrency(PLANT_TYPES.ananas.baseReward)}\n**Kohl** (2h): ${utils.formatCurrency(PLANT_TYPES.kohl.baseReward)}\nüíö **D√ºnger-Bonus:** +25% Ertrag`,
        inline: true
    });

    embed.addFields({
        name: '‚ö†Ô∏è WICHTIGER HINWEIS',
        value: '**üöó Gallivanter-Regel:**\nBatterie/Pilze/Beete **NICHT selbst einsammeln!**\n‚û°Ô∏è **In Gallivanter-Kofferaum legen** f√ºr Auszahlung!\n\n**Commands verwenden:**\n‚Ä¢ `/aktivit√§t-eintragen` f√ºr Events\n‚Ä¢ `/externe-arbeit` f√ºr Beete/Solar\n‚Ä¢ `/rekrutierung` f√ºr neue Mitglieder',
        inline: false
    });

    await interaction.reply({ embeds: [embed] });
}

async function handleActivityEntry(interaction) {
    const activityType = interaction.options.getString('typ');
    const location = interaction.options.getString('location').trim();
    const participantsStr = interaction.options.getString('teilnehmer').trim();
    const customAmount = interaction.options.getInteger('betrag');
    const userId = interaction.user.id;
    const username = interaction.user.displayName || interaction.user.username;
    const serverId = interaction.guildId;

    await interaction.deferReply();

    try {
        const activity = ACTIVITY_TYPES[activityType];
        if (!activity) {
            await interaction.followUp('‚ùå Unbekannte Aktivit√§t!');
            return;
        }

        const participants = participantsStr.split(',').map(p => p.trim()).filter(p => p.length > 0);
        const payoutPerPerson = customAmount || activity.reward;
        const totalPayout = participants.length * payoutPerPerson;

        const { rows } = await db.query(`
            INSERT INTO general_activities (user_id, username, activity_type, location, participants, amount, details, server_id, payout_amount)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
            RETURNING id
        `, [userId, username, activityType, location, JSON.stringify(participants), payoutPerPerson, activity.description, serverId, totalPayout]);

        const activityId = rows[0]?.id || Math.floor(Math.random() * 1000) + 1;

        for (const participant of participants) {
            await logActivity(userId, participant, activityType.toUpperCase(), 'GENERAL', activityId, location, 
                            `${activity.name} - Organisiert von ${username}`, serverId, 0, payoutPerPerson, null, 'events');
        }

        const embed = new EmbedBuilder()
            .setColor('#FF6B35')
            .setTitle(`${activity.emoji} ${activity.name} erfolgreich eingetragen!`)
            .setDescription('Aktivit√§t wurde f√ºr Auszahlung registriert')
            .addFields(
                { name: 'üë§ Eingetragen von', value: username, inline: true },
                { name: 'üÜî Aktivit√§ts-ID', value: `**#${activityId}**`, inline: true },
                { name: 'üìç Ort', value: `\`${location}\``, inline: true },
                { name: 'üë• Teilnehmer', value: `**${participants.length}** Personen`, inline: true },
                { name: 'üí∞ Pro Person', value: `**${utils.formatCurrency(payoutPerPerson)}**`, inline: true },
                { name: 'üí∞ Gesamt-Auszahlung', value: `**${utils.formatCurrency(totalPayout)}**`, inline: true }
            )
            .setFooter({ text: 'Russkaya Familie üá∑üá∫ ‚Ä¢ Aktivit√§t registriert' })
            .setTimestamp();

        let participantsList = participants.join(', ');
        if (participantsList.length > 1000) {
            participantsList = participantsList.substring(0, 1000) + '...';
        }
        embed.addFields({
            name: 'üìã Teilnehmer-Liste',
            value: participantsList,
            inline: false
        });

        await interaction.followUp({ embeds: [embed] });

    } catch (error) {
        console.error('‚ùå Activity Entry Error:', error);
        await interaction.followUp('‚ùå Fehler beim Eintragen der Aktivit√§t!');
    }
}

async function handleExternalWork(interaction) {
    const workType = interaction.options.getString('typ');
    const location = interaction.options.getString('location').trim();
    const amount = interaction.options.getInteger('anzahl');
    const details = interaction.options.getString('details') || '';
    const userId = interaction.user.id;
    const username = interaction.user.displayName || interaction.user.username;
    const serverId = interaction.guildId;

    await interaction.deferReply();

    try {
        let ratePerUnit, workName, emoji;
        
        switch (workType) {
            case 'beete_duengen':
                ratePerUnit = PAYOUT_RATES.BEETE_DUENGEN;
                workName = 'Beete d√ºngen';
                emoji = 'üå±';
                break;
            case 'solar_reparieren':
                ratePerUnit = PAYOUT_RATES.SOLAR_REPARIEREN;
                workName = 'Solar reparieren';
                emoji = 'üîß';
                break;
            default:
                await interaction.followUp('‚ùå Unbekannte Arbeitsart!');
                return;
        }

        const totalPayout = amount * ratePerUnit;

        const { rows } = await db.query(`
            INSERT INTO external_work (user_id, username, work_type, location, amount, rate_per_unit, total_payout, details, server_id)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
            RETURNING id
        `, [userId, username, workType, location, amount, ratePerUnit, totalPayout, details, serverId]);

        const workId = rows[0]?.id || Math.floor(Math.random() * 1000) + 1;

        await logActivity(userId, username, workType.toUpperCase(), 'EXTERNAL', workId, location, 
                        `${amount}x ${workName} - ${utils.formatCurrency(ratePerUnit)} pro Einheit`, serverId, 0, totalPayout, null, 'external');

        const embed = new EmbedBuilder()
            .setColor('#32CD32')
            .setTitle(`${emoji} ${workName} erfolgreich eingetragen!`)
            .setDescription('Externe Arbeit wurde f√ºr Auszahlung registriert')
            .addFields(
                { name: 'üë§ Durchgef√ºhrt von', value: username, inline: true },
                { name: 'üÜî Arbeits-ID', value: `**#${workId}**`, inline: true },
                { name: 'üìç Ort', value: `\`${location}\``, inline: true },
                { name: 'üìä Anzahl', value: `**${amount}** Einheiten`, inline: true },
                { name: 'üí∞ Pro Einheit', value: `**${utils.formatCurrency(ratePerUnit)}**`, inline: true },
                { name: 'üí∞ Gesamt-Auszahlung', value: `**${utils.formatCurrency(totalPayout)}**`, inline: true }
            )
            .setFooter({ text: 'Russkaya Familie üá∑üá∫ ‚Ä¢ Externe Arbeit registriert' })
            .setTimestamp();

        if (details) {
            embed.addFields({
                name: 'üìù Details',
                value: details,
                inline: false
            });
        }

        embed.addFields({
            name: '‚ö†Ô∏è Wichtiger Hinweis',
            value: 'üöó **Vergiss nicht:** Ertrag in Gallivanter-Kofferaum legen f√ºr Auszahlung!',
            inline: false
        });

        await interaction.followUp({ embeds: [embed] });

    } catch (error) {
        console.error('‚ùå External Work Error:', error);
        await interaction.followUp('‚ùå Fehler beim Eintragen der externen Arbeit!');
    }
}

async function handleRecruitment(interaction) {
    const newPlayerName = interaction.options.getString('neuer_spieler').trim();
    const discordUser = interaction.options.getUser('discord_user');
    const recruiterId = interaction.user.id;
    const recruiterName = interaction.user.displayName || interaction.user.username;
    const serverId = interaction.guildId;

    await interaction.deferReply();

    try {
        const recruitedId = discordUser ? discordUser.id : null;

        const { rows } = await db.query(`
            INSERT INTO recruitments (recruiter_id, recruiter_name, recruited_id, recruited_name, server_id)
            VALUES ($1, $2, $3, $4, $5)
            RETURNING id
        `, [recruiterId, recruiterName, recruitedId, newPlayerName, serverId]);

        const recruitmentId = rows[0]?.id || Math.floor(Math.random() * 1000) + 1;

        await logActivity(recruiterId, recruiterName, 'RECRUITMENT_STARTED', 'RECRUITMENT', recruitmentId, 'Discord/GTA', 
                        `Rekrutierung von ${newPlayerName}`, serverId, 0, 0, null, 'recruitment');

        const embed = new EmbedBuilder()
            .setColor('#4169E1')
            .setTitle('üë• Neue Rekrutierung gestartet!')
            .setDescription('Rekrutierung wurde erfolgreich registriert')
            .addFields(
                { name: 'üë§ Rekrutierer', value: recruiterName, inline: true },
                { name: 'üÜî Rekrutierungs-ID', value: `**#${recruitmentId}**`, inline: true },
                { name: 'üÜï Neuer Spieler', value: newPlayerName, inline: true },
                { name: 'üí¨ Discord', value: discordUser ? `<@${discordUser.id}>` : 'Nicht verkn√ºpft', inline: true },
                { name: '‚è∞ Startdatum', value: `<t:${Math.floor(Date.now() / 1000)}:F>`, inline: true },
                { name: 'üí∞ Potentielle Auszahlung', value: `**${utils.formatCurrency(ACTIVITY_TYPES.recruitment.reward)}**`, inline: true }
            )
            .setFooter({ text: 'Russkaya Familie üá∑üá∫ ‚Ä¢ Verwende /rekrutierung-abschlie√üen nach 1 Woche' })
            .setTimestamp();

        embed.addFields({
            name: 'üìã N√§chste Schritte',
            value: `1. **Neue Person mindestens 1 Woche aktiv halten**\n2. **Nach 1 Woche:** \`/rekrutierung-abschlie√üen id:${recruitmentId}\`\n3. **Auszahlung:** ${utils.formatCurrency(ACTIVITY_TYPES.recruitment.reward)} erhalten`,
            inline: false
        });

        await interaction.followUp({ embeds: [embed] });

    } catch (error) {
        console.error('‚ùå Recruitment Error:', error);
        await interaction.followUp('‚ùå Fehler beim Registrieren der Rekrutierung!');
    }
}

async function handleRecruitmentComplete(interaction) {
    const recruitmentId = interaction.options.getInteger('id');
    const userId = interaction.user.id;
    const serverId = interaction.guildId;

    await interaction.deferReply();

    try {
        const { rows: recruitmentRows } = await db.query(`
            SELECT * FROM recruitments 
            WHERE id = $1 AND server_id = $2 AND recruiter_id = $3 AND status = 'active'
        `, [recruitmentId, serverId, userId]);

        if (recruitmentRows.length === 0) {
            await interaction.followUp('‚ùå Rekrutierung nicht gefunden oder bereits abgeschlossen!');
            return;
        }

        const recruitment = recruitmentRows[0];

        const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
        const recruitedAt = new Date(recruitment.recruited_at);

        if (recruitedAt > weekAgo) {
            const timeRemaining = weekAgo.getTime() - recruitedAt.getTime();
            const daysRemaining = Math.ceil(timeRemaining / (24 * 60 * 60 * 1000));
            await interaction.followUp(`‚ùå Rekrutierung noch nicht 1 Woche alt! Noch **${Math.abs(daysRemaining)}** Tag(e) warten.`);
            return;
        }

        await db.query(`
            UPDATE recruitments 
            SET status = 'completed', week_completed = TRUE, payout_given = TRUE
            WHERE id = $1
        `, [recruitmentId]);

        const payout = ACTIVITY_TYPES.recruitment.reward;

        await logActivity(userId, recruitment.recruiter_name, 'RECRUITMENT_COMPLETED', 'RECRUITMENT', recruitmentId, 'Completed', 
                        `1-Woche Rekrutierung von ${recruitment.recruited_name} abgeschlossen`, serverId, 0, payout, null, 'recruitment');

        const embed = new EmbedBuilder()
            .setColor('#00FF00')
            .setTitle('‚úÖ Rekrutierung erfolgreich abgeschlossen!')
            .setDescription('Gl√ºckwunsch! Du erh√§ltst deine Rekrutierungs-Auszahlung.')
            .addFields(
                { name: 'üë§ Rekrutierer', value: recruitment.recruiter_name, inline: true },
                { name: 'üÜî Rekrutierungs-ID', value: `**#${recruitmentId}**`, inline: true },
                { name: 'üÜï Rekrutierte Person', value: recruitment.recruited_name, inline: true },
                { name: 'üìÖ Rekrutiert am', value: `<t:${Math.floor(new Date(recruitment.recruited_at).getTime() / 1000)}:F>`, inline: true },
                { name: '‚è∞ Dauer', value: `**${Math.floor((Date.now() - new Date(recruitment.recruited_at)) / (24 * 60 * 60 * 1000))}** Tage`, inline: true },
                { name: 'üí∞ Auszahlung', value: `**${utils.formatCurrency(payout)}**`, inline: true }
            )
            .setFooter({ text: 'Russkaya Familie üá∑üá∫ ‚Ä¢ Danke f√ºr die erfolgreiche Rekrutierung!' })
            .setTimestamp();

        await interaction.followUp({ embeds: [embed] });

    } catch (error) {
        console.error('‚ùå Recruitment Complete Error:', error);
        await interaction.followUp('‚ùå Fehler beim Abschlie√üen der Rekrutierung!');
    }
}

async function handleMyActivities(interaction) {
    const timeframe = interaction.options.getString('zeitraum') || 'today';
    const userId = interaction.user.id;
    const username = interaction.user.displayName || interaction.user.username;
    const serverId = interaction.guildId;

    await interaction.deferReply();

    try {
        let dateFilter, timeframeName;
        const now = new Date();
        
        switch (timeframe) {
            case 'today':
                dateFilter = now.toISOString().split('T')[0];
                timeframeName = 'Heute';
                break;
            case 'week':
                const weekStart = new Date(now.setDate(now.getDate() - now.getDay()));
                dateFilter = weekStart.toISOString().split('T')[0];
                timeframeName = 'Diese Woche';
                break;
            case 'month':
                const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
                dateFilter = monthStart.toISOString().split('T')[0];
                timeframeName = 'Dieser Monat';
                break;
            default:
                dateFilter = now.toISOString().split('T')[0];
                timeframeName = 'Heute';
        }

        const { rows: activities } = await db.query(`
            SELECT * FROM activity_logs 
            WHERE user_id = $1 AND server_id = $2 AND timestamp >= $3
            ORDER BY timestamp DESC
        `, [userId, serverId, dateFilter]);

        const totalReward = activities.reduce((sum, act) => sum + (parseFloat(act.reward) || 0), 0);

        const embed = new EmbedBuilder()
            .setColor('#9932CC')
            .setTitle(`üìä ${username}'s Aktivit√§ten - ${timeframeName}`)
            .setDescription(`√úbersicht aller deiner Aktivit√§ten und Verdienste`)
            .addFields(
                { name: 'üìà Gesamt-Verdienst', value: `**${utils.formatCurrency(totalReward)}**`, inline: true },
                { name: 'üìã Gesamt-Aktivit√§ten', value: `**${activities.length}**`, inline: true },
                { name: 'üìÖ Zeitraum', value: timeframeName, inline: true }
            )
            .setFooter({ text: 'Russkaya Familie üá∑üá∫ ‚Ä¢ Deine Leistung z√§hlt!' })
            .setTimestamp();

        if (activities.length > 0) {
            const recentActivities = activities.slice(0, 5).map(act => 
                `${act.action_type} - ${utils.formatCurrency(parseFloat(act.reward) || 0)}`
            ).join('\n');
            
            embed.addFields({
                name: 'üïê Letzte Aktivit√§ten',
                value: recentActivities || 'Keine Aktivit√§ten',
                inline: false
            });
        }

        if (totalReward === 0) {
            embed.setDescription(`Keine Aktivit√§ten f√ºr ${timeframeName.toLowerCase()} gefunden.`);
        }

        await interaction.followUp({ embeds: [embed] });

    } catch (error) {
        console.error('‚ùå My Activities Error:', error);
        await interaction.followUp('‚ùå Fehler beim Abrufen der Aktivit√§ten!');
    }
}

// ===== BACKUP & STATISTIKEN =====
async function handleBackup(interaction) {
    const format = interaction.options.getString('format') || 'csv';
    const serverId = interaction.guildId;

    await interaction.deferReply({ ephemeral: true });

    try {
        const today = new Date().toISOString().split('T')[0];
        
        if (format === 'json') {
            // Vereinfachtes JSON Backup f√ºr v3.0
            const { rows: activities } = await db.query(`
                SELECT * FROM activity_logs 
                WHERE server_id = $1 AND DATE(timestamp) = $2
                ORDER BY timestamp DESC
            `, [serverId, today]);

            const payoutJson = {
                metadata: {
                    generatedAt: new Date().toISOString(),
                    date: today,
                    serverId: serverId,
                    version: '3.0.0'
                },
                activities: activities,
                summary: {
                    totalActivities: activities.length,
                    totalReward: activities.reduce((sum, act) => sum + (parseFloat(act.reward) || 0), 0)
                }
            };

            const jsonBuffer = Buffer.from(JSON.stringify(payoutJson, null, 2), 'utf8');
            const jsonAttachment = new AttachmentBuilder(jsonBuffer, { name: `russkaya_auszahlungen_v3_${today}.json` });

            const embed = new EmbedBuilder()
                .setColor('#FFD700')
                .setTitle('üí∞ Auszahlungs-Backup v3.0')
                .setDescription(`Backup f√ºr ${today} erstellt`)
                .setFooter({ text: 'Russkaya Familie üá∑üá∫ ‚Ä¢ v3.0' })
                .setTimestamp();

            await interaction.followUp({ 
                embeds: [embed], 
                files: [jsonAttachment], 
                ephemeral: true 
            });
            
        } else {
            // Standard CSV Backup
            const { rows: plants } = await db.query('SELECT * FROM plants WHERE server_id = $1 ORDER BY planted_at DESC LIMIT 100', [serverId]);
            const { rows: solar } = await db.query('SELECT * FROM solar_panels WHERE server_id = $1 ORDER BY placed_at DESC LIMIT 100', [serverId]);
            const { rows: logs } = await db.query('SELECT * FROM activity_logs WHERE server_id = $1 ORDER BY timestamp DESC LIMIT 200', [serverId]);

            let csvContent = `RUSSKAYA FAMILIE BACKUP v3.0 - ${today}\n\n`;
            csvContent += 'PFLANZEN:\n';
            csvContent += 'ID,User_ID,Username,Plant_Type,Location,Status,Fertilized_By,Harvested_By\n';
            
            plants.forEach(p => {
                csvContent += `${p.id || 'N/A'},${p.user_id},${p.username},${p.plant_type || 'mandarinen'},${p.location},${p.status},${p.fertilized_by || ''},${p.harvested_by || ''}\n`;
            });

            csvContent += '\nSOLAR PANELS:\n';
            csvContent += 'ID,User_ID,Username,Location,Status,Repairs_Count,Collected_By\n';
            
            solar.forEach(s => {
                csvContent += `${s.id || 'N/A'},${s.user_id},${s.username},${s.location},${s.status},${s.repairs_count || 0},${s.collected_by || ''}\n`;
            });

            const buffer = Buffer.from(csvContent, 'utf8');
            const attachment = new AttachmentBuilder(buffer, { name: `russkaya_backup_v3_${today}.csv` });

            const embed = new EmbedBuilder()
                .setColor('#00FF00')
                .setTitle('üíæ Standard-Backup v3.0')
                .setDescription('CSV-Backup der Hauptdaten')
                .addFields(
                    { name: 'üå± Pflanzen', value: `${plants.length}`, inline: true },
                    { name: '‚òÄÔ∏è Solar', value: `${solar.length}`, inline: true },
                    { name: 'üìã Logs', value: `${logs.length}`, inline: true }
                )
                .setFooter({ text: 'Russkaya Familie üá∑üá∫ ‚Ä¢ v3.0' })
                .setTimestamp();

            await interaction.followUp({ embeds: [embed], files: [attachment], ephemeral: true });
        }

    } catch (error) {
        console.error('‚ùå Backup Error:', error);
        await interaction.followUp({ content: '‚ùå Fehler beim Erstellen des Backups!', ephemeral: true });
    }
}

async function handleHelp(interaction) {
    const embed = new EmbedBuilder()
        .setColor('#0099FF')
        .setTitle('‚ùì Russkaya Familie Bot v3.0 - Hilfe')
        .setDescription('**Alle Commands im √úberblick - Jetzt mit ALLEN GTA RP Aktivit√§ten!**')
        .addFields(
            {
                name: 'üå± Pflanzen (3 Typen mit Smart Timer)',
                value: '`/pflanze-s√§en location: pflanzentyp:` - Neue Pflanze (Mandarinen/Ananas/Kohl)\n`/pflanze-d√ºngen id:` - D√ºngen (pausiert Timer!)\n`/pflanze-ernten id: car:` - Ernten (Gallivanter f√ºr Auszahlung!)\n`/pflanzen-status [filter:]` - Status anzeigen\n`/pflanzen-info` - Alle Pflanzentypen & Details',
                inline: true
            },
            {
                name: '‚òÄÔ∏è Solar (mit Smart Timer)',
                value: '`/solar-aufstellen location:` - Panel aufstellen\n`/solar-reparieren id:` - Reparieren (pausiert Timer!)\n`/solar-sammeln id: car:` - Batterie sammeln (Gallivanter!)\n`/solar-status` - Aktive Panels',
                inline: true
            },
            {
                name: 'üî´ Events & Raids (NEU!)',
                value: '`/aktivit√§t-eintragen typ: location: teilnehmer:` - Raids/Events registrieren\n`/aktivit√§ten-info` - Alle Aktivit√§ten & Auszahlungsraten anzeigen',
                inline: true
            },
            {
                name: 'üåæ Externe Arbeiten (NEU!)',
                value: '`/externe-arbeit typ: location: anzahl:` - Beete d√ºngen/Solar reparieren extern\nüí∞ **Beete:** 1.000‚Ç¨ pro Beet\nüí∞ **Solar:** 1.000‚Ç¨ pro Reparatur',
                inline: true
            },
            {
                name: 'üë• Rekrutierung (NEU!)',
                value: '`/rekrutierung neuer_spieler: [discord_user:]` - Rekrutierung starten\n`/rekrutierung-abschlie√üen id:` - Nach 1 Woche (20.000‚Ç¨ Auszahlung)',
                inline: true
            },
            {
                name: 'üìä Statistiken & Pers√∂nlich',
                value: '`/meine-aktivit√§ten [zeitraum:]` - Pers√∂nliche √úbersicht\n`/statistiken` - Umfassende Server-Stats v3.0\n`/help` - Diese Hilfe',
                inline: true
            }
        )
        .setFooter({ text: 'Russkaya Familie üá∑üá∫ ‚Ä¢ v3.0 Vollst√§ndiges GTA RP System' })
        .setTimestamp();

    embed.addFields({
        name: 'üöó WICHTIGE GALLIVANTER-REGEL',
        value: '**F√úR AUSZAHLUNGEN:** Batterie/Pilze/Beete **NICHT** selbst einsammeln!\n‚û°Ô∏è **In GALLIVANTER-KOFFERAUM** legen!\n\n**Admin Backup:** `/backup format:json` f√ºr t√§gliche Auszahlungsberechnung',
        inline: false
    });

    await interaction.reply({ embeds: [embed] });
}

async function handleStatistics(interaction) {
    const serverId = interaction.guildId;
    await interaction.deferReply();

    try {
        const { rows: plantStats } = await db.query(`
            SELECT 
                COUNT(*) FILTER (WHERE status = 'planted') as active_plants,
                COUNT(*) FILTER (WHERE status = 'harvested') as harvested_plants,
                COUNT(*) FILTER (WHERE plant_type = 'mandarinen') as mandarinen_count,
                COUNT(*) FILTER (WHERE plant_type = 'ananas') as ananas_count,
                COUNT(*) FILTER (WHERE plant_type = 'kohl') as kohl_count,
                COUNT(*) FILTER (WHERE timer_paused_at IS NOT NULL AND status = 'planted') as paused_plants
            FROM plants WHERE server_id = $1
        `, [serverId]);

        const { rows: solarStats } = await db.query(`
            SELECT 
                COUNT(*) FILTER (WHERE status = 'active') as active_solar,
                COUNT(*) FILTER (WHERE status = 'collected') as collected_solar,
                COUNT(*) FILTER (WHERE timer_paused_at IS NOT NULL AND status = 'active') as paused_solar
            FROM solar_panels WHERE server_id = $1
        `, [serverId]);

        const { rows: activityStats } = await db.query(`
            SELECT COUNT(DISTINCT user_id) as active_users
            FROM activity_logs WHERE server_id = $1
        `, [serverId]);

        const plants = plantStats[0] || {};
        const solar = solarStats[0] || {};
        const activity = activityStats[0] || {};

        const embed = new EmbedBuilder()
            .setColor('#9900FF')
            .setTitle('üìä Russkaya Familie - Server Statistiken v3.0')
            .setDescription('Gesamt√ºbersicht aller Aktivit√§ten **mit neuen Features**')
            .addFields(
                {
                    name: 'üå± Pflanzen',
                    value: `**${plants.active_plants || 0}** aktiv (‚è∏Ô∏è ${plants.paused_plants || 0} pausiert)\n**${plants.harvested_plants || 0}** geerntet\n**${(plants.active_plants || 0) + (plants.harvested_plants || 0)}** gesamt`,
                    inline: true
                },
                {
                    name: 'üå± Pflanzentypen',
                    value: `üçä **${plants.mandarinen_count || 0}** Mandarinen\nüçç **${plants.ananas_count || 0}** Ananas\nü•¨ **${plants.kohl_count || 0}** Kohl`,
                    inline: true
                },
                {
                    name: '‚òÄÔ∏è Solar',
                    value: `**${solar.active_solar || 0}** aktiv (‚è∏Ô∏è ${solar.paused_solar || 0} pausiert)\n**${solar.collected_solar || 0}** eingesammelt\n**${(solar.active_solar || 0) + (solar.collected_solar || 0)}** gesamt`,
                    inline: true
                },
                {
                    name: 'üë• Community',
                    value: `**${activity.active_users || 0}** aktive Spieler\n**${interaction.guild.memberCount}** Server-Mitglieder\n**${client.guilds.cache.size}** aktive Server`,
                    inline: true
                },
                {
                    name: '‚è∏Ô∏è Timer-System',
                    value: `**${(plants.paused_plants || 0) + (solar.paused_solar || 0)}** pausierte Timer\n**${((plants.active_plants || 0) - (plants.paused_plants || 0)) + ((solar.active_solar || 0) - (solar.paused_solar || 0))}** laufende Timer`,
                    inline: true
                },
                {
                    name: 'üéØ Effizienz',
                    value: `**${Math.round(((plants.paused_plants || 0) / Math.max(plants.active_plants || 1, 1)) * 100)}%** Pflanzen optimal getimt\n**${Math.round(((solar.paused_solar || 0) / Math.max(solar.active_solar || 1, 1)) * 100)}%** Solar optimal getimt`,
                    inline: true
                }
            )
            .setFooter({ text: 'Russkaya Familie üá∑üá∫ ‚Ä¢ v3.0 mit Timer-Statistiken!' })
            .setTimestamp();

        await interaction.followUp({ embeds: [embed] });

    } catch (error) {
        console.error('‚ùå Statistics Error:', error);
        await interaction.followUp('‚ùå Fehler beim Abrufen der Statistiken!');
    }
}

// ===== HELPER FUNCTIONS =====
async function logActivity(userId, username, actionType, itemType, itemId, location, details, serverId, experience = 0, reward = 0, plantType = null, activityCategory = 'farming') {
    try {
        await db.query(`
            INSERT INTO activity_logs (user_id, username, action_type, item_type, item_id, location, details, server_id, experience, reward, plant_type, activity_category)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
        `, [userId, username, actionType, itemType, itemId, location, details, serverId, experience, reward, plantType, activityCategory]);
    } catch (error) {
        console.error('‚ùå Log Activity Error:', error);
    }
}

// ===== BACKGROUND TASKS =====
function startBackgroundTasks() {
    // Timer-√úberwachung alle 5 Minuten
    cron.schedule('*/5 * * * *', async () => {
        try {
            await checkPausedTimers();
        } catch (error) {
            console.error('‚ùå Timer Check Error:', error);
        }
    });

    // Automatische Backups (t√§glich um 03:00)
    cron.schedule('0 3 * * *', async () => {
        console.log('üíæ Erstelle automatisches Backup...');
    }, { timezone: 'Europe/Berlin' });
    
    // Alte Eintr√§ge bereinigen (w√∂chentlich)
    cron.schedule('0 4 * * 0', async () => {
        console.log('üßπ Bereinige alte Eintr√§ge...');
        try {
            const cutoffDate = new Date(Date.now() - config.timers.cleanupInterval * 60 * 1000).toISOString();
            await db.query(`DELETE FROM plants WHERE status = 'harvested' AND harvested_at < $1`, [cutoffDate]);
            await db.query(`DELETE FROM solar_panels WHERE status = 'collected' AND collected_at < $1`, [cutoffDate]);
            await db.query(`DELETE FROM activity_logs WHERE timestamp < $1`, [cutoffDate]);
        } catch (error) {
            console.error('‚ùå Cleanup Error:', error);
        }
    }, { timezone: 'Europe/Berlin' });
    
    console.log('‚è∞ Background Tasks v3.0 gestartet');
}

async function checkPausedTimers() {
    try {
        // Pr√ºfe pausierte Pflanzen
        const { rows: pausedPlants } = await db.query(`
            SELECT * FROM plants 
            WHERE status = 'planted' AND timer_paused_at IS NOT NULL 
            AND fertilized_at IS NOT NULL
        `);

        for (const plant of pausedPlants) {
            const plantType = PLANT_TYPES[plant.plant_type];
            if (!plantType) continue;

            const timeSinceFertilized = (Date.now() - new Date(plant.fertilized_at)) / (1000 * 60);
            
            // Nach 30 Minuten Timer automatisch reaktivieren
            if (timeSinceFertilized >= 30) {
                await db.query(`UPDATE plants SET timer_paused_at = NULL WHERE id = $1`, [plant.id]);
                console.log(`üå± Timer f√ºr Pflanze #${plant.id} (${plant.plant_type}) reaktiviert`);
            }
        }

        // Pr√ºfe pausierte Solar-Panels
        const { rows: pausedSolar } = await db.query(`
            SELECT * FROM solar_panels 
            WHERE status = 'active' AND timer_paused_at IS NOT NULL 
            AND last_repair_at IS NOT NULL
        `);

        for (const panel of pausedSolar) {
            const timeSinceRepair = (Date.now() - new Date(panel.last_repair_at)) / (1000 * 60);
            
            // Nach 30 Minuten Timer automatisch reaktivieren
            if (timeSinceRepair >= 30) {
                await db.query(`UPDATE solar_panels SET timer_paused_at = NULL WHERE id = $1`, [panel.id]);
                console.log(`‚òÄÔ∏è Timer f√ºr Solar-Panel #${panel.id} reaktiviert`);
            }
        }

    } catch (error) {
        console.error('‚ùå Check Paused Timers Error:', error);
    }
}

// ===== HEALTH CHECK SERVER =====
function startHealthCheckServer() {
    const app = express();
    
    app.get('/', (req, res) => {
        res.json({
            status: 'online',
            version: '3.0.0',
            bot: client.user?.tag || 'starting',
            uptime: process.uptime(),
            timestamp: new Date().toISOString(),
            guilds: client.guilds.cache.size,
            users: client.users.cache.size,
            features: {
                plantTypes: Object.keys(PLANT_TYPES).length,
                activityTypes: Object.keys(ACTIVITY_TYPES).length,
                timerPause: true,
                payoutSystem: true,
                raidSystem: true,
                recruitmentSystem: true
            }
        });
    });
    
    app.get('/health', async (req, res) => {
        try {
            await db.query('SELECT 1');
            res.json({ status: 'healthy', database: 'connected', version: '3.0.0' });
        } catch (error) {
            res.status(503).json({ status: 'unhealthy', database: 'disconnected', error: error.message });
        }
    });
    
    app.listen(config.port, () => {
        console.log(`üåê Health Check Server v3.0 l√§uft auf Port ${config.port}`);
    });
}

// ===== ERROR HANDLING & SHUTDOWN =====
process.on('unhandledRejection', error => {
    console.error('‚ùå Unhandled promise rejection:', error);
});

process.on('uncaughtException', error => {
    console.error('‚ùå Uncaught exception:', error);
    process.exit(1);
});

process.on('SIGINT', async () => {
    console.log('üõë Bot v3.0 wird heruntergefahren...');
    
    try {
        if (db && db.end) {
            await db.end();
            console.log('‚úÖ Datenbank-Verbindung geschlossen');
        }
        
        client.destroy();
        console.log('‚úÖ Bot v3.0 heruntergefahren');
        process.exit(0);
    } catch (error) {
        console.error('‚ùå Fehler beim Herunterfahren:', error);
        process.exit(1);
    }
});

// ===== BOT LOGIN =====
if (!config.token) {
    console.error('‚ùå DISCORD_TOKEN Environment Variable nicht gesetzt!');
    console.error('üí° Setze DISCORD_TOKEN in Railway Environment Variables');
    process.exit(1);
}

client.login(config.token).catch(error => {
    console.error('‚ùå Bot Login Error:', error);
    console.error('üí° √úberpr√ºfe deinen Discord Bot Token!');
    process.exit(1);
});

console.log('üöÄ Russkaya Familie Bot v3.0 wird gestartet...');
console.log('üá∑üá∫ –†–∞–∑–≤–∏–≤–∞–π—Å—è —Å —Å–µ–º—å—ë–π –†—É—Å—Å–∫–∞—è!');
console.log('üî´ NEU: Vollst√§ndiges Raid & Event System');
console.log('üåæ NEU: Externe Arbeiten (Beete, Solar)');
console.log('üë• NEU: Rekrutierungs-System (20.000‚Ç¨)');
console.log('üçä NEU: 3 Pflanzentypen mit Smart Timer');
console.log('üí∏ NEU: Gelddruckmaschine & passive Einnahmen');
console.log('üöó WICHTIG: Gallivanter-Regel f√ºr Auszahlungen!');
console.log('‚ö° Railway Deployment Ready - Production Mode v3.0!');
